---
title: About
layout: page
---
![Profile Image]({{ site.url }}/{{ site.picture }})

<p>I am a graduate student in Software Engineering at Carnegie Mellon University - School of Computer Science (Institute for Software Research).
Previously, I was a Senior Software Engineer at Myntra Designs, one of India's leading fashion ecommerce companies.</p>

<p>My current interests at grad school are the design, architecture, and management of large-scale software systems, along with Software engineering for Machine Learning and AI systems.</p>

<h3>CMU - Course Plan</h3>

TLDR; (scroll below for descriptions)

<h4>Fall 2019</h4>
<ul class="skill-list">
	<li>17651 - Models of Software Systems</li>
	<li>17652 - Methods - Deciding what to design</li>
	<li>17653 - Managing Software Development</li>
	<li>15513 - Intro to Computer Systems</li>
	<li>17657A - Communication for Software Engineers II</li>
</ul>
<h4>Spring 2020</h4>
<ul class="skill-list">
	<li>17654 - Analysis of Software Artifacts</li>
	<li>17655 - Architectures for Software Systems</li>
	<li>11663 - Applied Machine Learning</li>
	<li>80705 - Game Theory</li>
	<li>17671 - Software Development Studio I</li>
	<li>17657A - Communication for Software Engineers II</li>
</ul>
<h4>Summer 2020</h4>
<ul class="skill-list">
	<li>17645 - Software Engineering for AI-Enabled Systems</li>
	<li>17672 - Software Development Studio II</li>
</ul>
<h4>Fall 2020</h4>
<ul class="skill-list">
	<li>17673 - Software Development Studio III</li>
	<li>(Tentative) 05631 - Software Structures for User Interfaces</li>
	<li>(Tentative) 05618 - Human AI Interaction</li>
</ul>

<h3>Course Descriptions</h3>

<h4>17651 - Models of Software Systems</h4>
<ul class="skill-list">
	<li><strong>Overview:</strong> This course is concerned with formally modeling software systems, such as the standard models for representing sequential and concurrent systems, such as state machines, algebras and traces. It shows how you can use different logics to specify properties of software systems, such as functional correctness, deadlock freedom, and internal consistency. Concepts such as composition mechanisms, abstraction relations, invariants, non-determinism, and inductive and denotational descriptions are recurrent themes throughout the course.<br/>
	</li>
	<li><strong>Topics Covered:</strong> Logic, State Machines and Reasoning, <a href="https://www.doc.ic.ac.uk/ltsa/">Labelled Transition System Analyser (LTSA)</a>, Relational models with <a href="http://alloy.lcs.mit.edu/alloy/">Alloy</a>, Concurrent Systems with Linear Temporal Logic, Probabilistic Modelling with <a href="https://www.prismmodelchecker.org/">PRISM</a>.
	</li>
</ul>

<h4>17652 - Methods - Deciding what to design</h4>
<ul class="skill-list">
	<li><strong>Overview:</strong> Practical development of software requires an understanding of successful methods for bridging the gap between a problem to be solved and a working software system. In this course, we studied a variety of ways to understand the problem that we're solving, the various factors that constrain the possible solutions, and approaches to deciding among alternatives. A few topics include: Requirements Engineering, Interviews/Surveys/Focus Groups, Goal Modeling, Use-case Analysis, User-centered design, Prototypes and Mockups.
	</li>
</ul>

<h4>17653 - Managing Software Development</h4>
<ul class="skill-list">
	<li><strong>Overview:</strong> Large scale software development requires the ability to manage resources — both human and computational — through control of the development process. This course is a breadth oriented course, designed to help technically-trained software engineers to acquire the knowledge and skills necessary to lead a project team, understand the relationship of software development to overall project engineering, estimate time and costs, and understand the software process.
	</li>
</ul>

<h4>15513 - Intro to Computer Systems</h4>
<ul class="skill-list">
	<li><a href="http://www.cs.cmu.edu/~213/">Course Page</a>
	</li>
	<li><strong>Topics:</strong> machine-level code and its generation by optimizing compilers, performance evaluation and optimization, computer arithmetic, memory organization and management, networking technology and protocols, and supporting concurrent computation.
	</li>
	<li> Assignments:</li>
	<ul>
		<li> C Programming Lab</li>
		<li> Data lab - working with low-level C code - bit manipulation.</li>
		<li> Bomb lab - defuse a bomb by reverse-engineering x86-64 assembly code.</li>
		<li> Attack lab - generate exploits by manipulating the heap by injecting x86-64 assembly code.</li>
		<li> Cache lab - design and implement a memory cache.</li>
		<li> Malloc lab - design and implement your own malloc library.</li>
		<li> TSH lab - design and implement a unix shell process, handling concurrency, threads, signals, and exceptions.</li>
		<li> Proxy lab - design and implement a proxy server in C handling concurrency, and threads with reasonable performance.</li>
	</ul>
</ul>

<h4>17654 - Analysis of Software Artifacts</h4>
<ul class="skill-list">
	<li><strong>Overview:</strong> This was one of the best classes I took at CMU. The course content focused heavily on analysis of software systems - measures and techniques. In the first half of the class we covered what to measure, how to measure, how to interpret measures and metrics. We also covered a wide range of techniques for measuring various quality attributes of software, from correctness, reliability, robustness to performance and security. Apart from regular individual assignments, we did a group project that covered testing a Building Automation System (BAMS) written in Java, and automate the analyses through development and deployment pipelines.
	</li>
</ul>

<h4>17655 - Architectures for Software Systems</h4>
<ul class="skill-list">
	<li><strong>Overview:</strong> This was probably the apex course for my program. The course started with identification of various software quality attributes from requirements and documenting them using a 6-part quality attribute scenario format. Having identified quality attributes such as Availability, Performance, Security, Modifiability, etc., we went over various techniques and strategies to promote those qualities. Apart from individual assignments for each major quality attribute, the course included a final project which required us to analyze a set of requirements for changes to a Building Automation System (BAMS), identify relevant quality attributes, and design the software architecture for the system-to-be.
	</li>
</ul>

<h4>11663 - Applied Machine Learning</h4>
<ul class="skill-list">
	<li><strong>Overview:</strong> My first formal academic foray into machine learning apart from past MOOCs. The course ideology was to cover machine learning without going too deep into the mathematics of the algorithms. We covered various machine learning techniques - decision trees, linear algorithms, forests, ensemble methods, neural networks and others. Apart from individual assignments 50% of the course grade was based on a substantial individual project which required us to solve any machine learning problem of our choice.
	</li>
</ul>

<h4>80705 - Game Theory</h4>
<ul class="skill-list">
	<li><strong>Overview:</strong> I took Game Theory because I wanted to take some non-CS course during my time at CMU. Game Theory has applications in a lot of fields from leadership decision making, to Computer Networks. We covered simple and mixed strategy Nash Equilibrium in games such as Traffic Flow, Prisoner's Dilemma, Cournot Duopoly, as well as topics such as rationalizability, repeated games, bargaining games, and auctions.
	</li>
</ul>

<h4>17645 - Software Engineering for AI-Enabled Systems</h4>
<ul class="skill-list">
	<li><a href="https://ckaestne.github.io/seai/S2020/">Course Page</a>
	<li><strong>Overview:</strong> This was a fun course. We covered aspects for software engineering for machine learning / AI systems. Much of the learning was from the perspective of a software engineering working with machine learning engineers or data scientists. The class was very discussion focused and that was very insightful. The individual assignments were technical and challenging. The course involved a group project where we had to build and deploy a recommendation system (my team used collaborative filtering) to serve recommendations to 1 million simulated users (watching at least one movie per day). Notably, my team had the lowest service downtime and the best performing recommendation system with an average rating of 4.06 on recommended movies.
	</li>
</ul>

<h4>Software Development Studio I/II/III</h4>
<ul class="skill-list">
	<li><strong>Overview:</strong> Studio is a year long capstone project in a team of 4 MSE students. My team (codename: Moonshot) is developing the ground control system software for the Moonranger rover which is being built by the CMU Robotics Institute and Astrobotic. The primary challenge of this project is (1) the work on the rover is progressing in parallel and therefore the requirements are highly unstructured and unspecified making modifiability one of our top concerns, and (2) the software needs to be extremely robust and reliable because well, it's a moon mission. We started from scratch and are expecting to hand over a reliable and extensible platform with adequate documentation to another MSE team next year.
	</li>
</ul>

<h2>Stuff I've worked with over the last 5 years</h2>

<ul class="skill-list">
	<li>Programming Languages: Python, Go, Java, Swift, Objective-C, Javascript</li>
	<li>Frameworks and Libraries: iOS Native SDK, React-Native, VueJS, PostgreSQL, MongoDB, Docker, Scikit-Learn</li>
	<li>Tools: Jenkins, XCode Server, Elasticsearch, Kibana, Logstash, Metricbeat</li>
</ul>